<!DOCTYPE html>

<body>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script>
        var width = 1200,
            height = 600,
            padding = 1.5, // separation between same-color nodes
            clusterPadding = 6, // separation between different-color nodes
            maxRadius = 20;

        var n = 35, // total number of nodes
            m = 5; // number of distinct clusters

        var color = d3.scale.category10()
            .domain(d3.range(m));

        // The largest node for each cluster.
        var clusters = new Array(m);
        var nodes = [];

        d3.json("data-no-race.json", function(error, data) {
            for (var i = 0; i < data.length; i++) {
                var obj = data[i];
                for (var key in obj) {
                    if (key != 'year') {
                        var year = obj['year'];
                        var r = obj[key] / 30;
                        d = {
                            cluster: year,
                            radius: r
                        };
                        if (!clusters[i] || (r > clusters[i].radius)) clusters[year] = d;
                        nodes.push(d);

                    }

                }

            }

            /* Wir definieren hier zufällige Knoten
            var nodes = d3.range(n).map(function() {
              var i = Math.floor(Math.random() * m), // Zufällige Zahl zwischen 0 und der maximalen Clusteranzahl 
                                                     // (Math.random() ist ein float zwischen 0 und 1)
                  
                  r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius, // Zufälliger Radius für jeden Knoten
                                                                                     // angepasst an maximalen Radius
                  d = {cluster: i, radius: r};
              if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d; // Knoten entweder erstellt oder überschrieben
              return d;
            });
            */

            // Use the pack layout to initialize node positions.
            d3.layout.pack()
                .sort(null)
                .size([width, height])
                .children(function(d) {
                    return d.values;
                })
                .value(function(d) {
                    return d.radius * d.radius;
                })
                .nodes({
                    values: d3.nest()
                        .key(function(d) {
                            return d.cluster;
                        })
                        .entries(nodes)
                });

            // Initialisierung des d3 force layouts
            var force = d3.layout.force()
                .nodes(nodes) // Alle unsere Knoten
                .size([width, height]) // Die maximale Größe
                .gravity(.01) // Anziehungskraft durch das Zentrum
                .charge(0) // Negative Werte lassen Knoten sich gegenseitig abstoßen, positive Werte ziehen sich gegenseitig an
                // Anpassung gemäß des Radius wären daher sinnvoll
                .on("tick", tick) // https://stackoverflow.com/a/28745519
                .start();

            // Wir erstellen einen SVG container und fügen ihn einfach zur DOM hinzu
            var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);

            // Dedinition wie ein Kreis auszusehen hat
            var node = svg.selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                // ganzes Cluster wird gleichmäßig gefärbt
                .style("fill", function(d) {
                    return color(d.cluster);
                })
                // andere Möglichkeiten Kreise zu zeichnen: http://www.d3noob.org/2014/02/styles-in-d3js.html
                .call(force.drag); // Kreis kann bewegt werden

            node.transition()
                .duration(750)
                .delay(function(d, i) {
                    return i * 5;
                })
                .attrTween("r", function(d) {
                    var i = d3.interpolate(0, d.radius);
                    return function(t) {
                        return d.radius = i(t);
                    };
                });

            function tick(e) {
                node
                    .each(cluster(10 * e.alpha * e.alpha))
                    .each(collide(.5))
                    .attr("cx", function(d) {
                        return d.x;
                    })
                    .attr("cy", function(d) {
                        return d.y;
                    });
            }

            // Move d to be adjacent to the cluster node.
            function cluster(alpha) {
                return function(d) {
                    var cluster = clusters[d.cluster];
                    if (cluster === d) return;
                    // Anpassung der Knotenposition an die Position des Clusters
                    var x = d.x - cluster.x,
                        y = d.y - cluster.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + cluster.radius;
                    if (l != r) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        cluster.x += x;
                        cluster.y += y;
                    }
                };
            }

            // Resolves collisions between d and all other circles.
            function collide(alpha) {
                var quadtree = d3.geom.quadtree(nodes);
                return function(d) {
                    var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                        nx1 = d.x - r,
                        nx2 = d.x + r,
                        ny1 = d.y - r,
                        ny2 = d.y + r;
                    quadtree.visit(function(quad, x1, y1, x2, y2) {
                        if (quad.point && (quad.point !== d)) {
                            var x = d.x - quad.point.x,
                                y = d.y - quad.point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
                            if (l < r) {
                                l = (l - r) / l * alpha;
                                d.x -= x *= l;
                                d.y -= y *= l;
                                quad.point.x += x;
                                quad.point.y += y;
                            }
                        }
                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    });
                };
            }

        });

    </script>
