<!DOCTYPE html>

<body>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <div class="control-panel">
        <label for="scalingOffset" style="display: inline-block; width: 160px; text-align: right">
            Scaling: <span id="scalingOffset-value" style="width:400px">...</span>
        </label>
        <input defaultValue="0" type="range" step="0.01" min="-10" max="10" id="scalingOffset">
        <br>
        <input name="clusterForceButton" type="button" value="Cluster Force" onclick="updateMode(0)" />
        <input name="centerForceButton" type="button" value="Center Force" onclick="updateMode(1)" />
    </div>
    <script>
    //================================================================================
    // Eigenschaften
    //================================================================================
    var width = 1000,
        height = 500,
        padding = 1, // Abstände zwischen gleichfarbigen Knoten
        clusterPadding = 15, //Abstände zwischen verschiedenfarbigen Clustern
        maxRadius = 100, // Maximaler Radius eines Knotens
        scaling = 0.03, // Skalierung der Knoten
        scalingOffset = 0,
        mode = 0;

    var x = width / 2;
    var y = height / 2;

    var n = 35, // Anzahl aller Knoten
        m = 5; // Anzahl von Clustern

    // Farbkategorie von d3: http://bl.ocks.org/aaizemberg/78bd3dade9593896a59d
    var color = d3.scale.category10()
        .domain(d3.range(m));

    var clusters = new Array(m); // Liste aller Cluster
    var nodes = []; // Liste aller Knoten


    function updateMode(newMode) {
        mode = newMode;
    	console.log("Changed mode to: " + mode);
    }

    //================================================================================
    // Dateneingang
    //================================================================================
    // TODO: Aktuell wird nicht die Gesamtanzahl an das Cluster selbst übergeben
    // Alle Funktionen finden innerhalb der JSON-Datei statt
    d3.json("data-no-race.json", function(error, data) {
        for (var i = 0; i < data.length; i++) {
            var obj = data[i]; // Für jedes Objekt werden alle Schlüssel durchlaufen
            for (var key in obj) { // key = {'race', 'sexuality', ...}
                if (key != 'year') { // Wir ordnen die Cluster nach dem Jahr
                    var year = obj['year'];
                    var r = obj[key] * scaling; // Radius ergibt sich aus dem Wert
                    d = { // Knoten wird erstellt
                        cluster: year,
                        key: key,
                        radius: r
                    };
                    // Letzter Wert wird an das Cluster übergeben
                    if (!clusters[i] || (r > clusters[i].radius)) clusters[year] = d;
                    // Knoten wird angefügt
                    nodes.push(d);
                }
            }
        }

        //================================================================================
        // Layout
        //================================================================================
        // Pack layout für die Ausgangspositionen der Nodes
        // https://d3-wiki.readthedocs.io/zh_CN/master/Pack-Layout/
        d3.layout.pack() // Knoten können mithilfe einer Funktion sortiert werden
            .sort(function(a, b) {
                return a.radius - b.radius;
            })
            .size([width, height])
            .children(function(d) {
                return d.values;
            })
            .value(function(d) {
                return d.radius * d.radius;
            })
            .nodes({ // Pack Layouts können auch Hierarchien abbilden
                values: d3.nest()
                    .key(function(d) {
                        return d.cluster;
                    })
                    .entries(nodes)
            });

        // Force Layout für die Zentrierung der Knoten und deren Bewegung im Raum
        var force = d3.layout.force()
            .nodes(nodes) // Alle unsere Knoten
            .size([width, height]) // Die maximale Größe
            .gravity(.01) // Anziehungskraft durch das Zentrum
            .charge(0) // Negative Werte lassen Knoten sich gegenseitig abstoßen, positive Werte ziehen sich gegenseitig an
            // Anpassung gemäß des Radius wären daher sinnvoll
            .on("tick", tick) // https://stackoverflow.com/a/28745519
            .start();

        // Wir erstellen einen SVG Container und fügen ihn einfach zur DOM hinzu
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        // Textzug mit Informationen zum Knoten
        var information = d3.select("body")
            .append("div")
            .style("position", "fixed")
            .style("z-index", "10")
            .style("top", "0")
            .style("right", "0")
            .style("visibility", "hidden")
            .text("a simple tooltip");

        d3.select("#scalingOffset").on("input", function() {
            scalingOffset = this.value * 10;
            d3.select("#scalingOffset-value").text(Math.floor(scalingOffset));

            svg.selectAll("circle")
                .attr("r", function(d) {
                    return d.radius + scalingOffset;
                });

        });

        var ring = d3.scale.linear()
            .clamp(true)
            .domain([25, 90 + scalingOffset]) // range of radius
            .range([Math.min(x, y) - 35, 0]);
        // smallest radius attracted to edge (35 -> Math.min(x, y) - 35)
        // largest radius attracted toward center (80 -> 0)




        //================================================================================
        // Kreiseigenschaften
        //================================================================================
        //Definition wie ein Kreis auszusehen hat
        var node = svg.selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", "node")
            .attr("r", function(d) {
                return d.radius + scalingOffset;
            })
            // ganzes Cluster wird gleichmäßig gefärbt
            .style("fill", function(d) {
                return color(d.cluster);
            })
            .style("opacity", .5)
            // andere Möglichkeiten Kreise zu zeichnen: http://www.d3noob.org/2014/02/styles-in-d3js.html
            .call(force.drag) // Kreis kann bewegt werden
            .on("mouseover", function(d) {
                d3.select(this).style("opacity", 1);
                return information.style("visibility", "visible").text("year: " + d.cluster + "  (" + d.key + ") amount: " + d.radius / scaling);
            })
            .on("mouseout", function(d) {
                d3.select(this).style("opacity", .5);
                return information.style("visibility", "hidden");
            });


        //================================================================================
        // Datenverarbeitung
        //================================================================================

        // Anwendung läuft nach Ticks
        function tick(e) {

            if (mode == 0) {
                node
                    .each(cluster(10 * e.alpha * e.alpha)) // ganzes Cluster wird mitgezogen
                    .each(collide(.8))
                    // Neue Position wird gespeichert
                    .attr("cx", function(d) {
                        return d.x;
                    })
                    .attr("cy", function(d) {
                        return d.y;
                    })
            }
            if (mode == 1) {
                node
                    //.each(cluster(10 * e.alpha * e.alpha)) // ganzes Cluster wird mitgezogen
                    .each(gravity(.8 * e.alpha))
                    .each(collide(.8)) // Kollisionen werden verechnet
                    // Neue Position wird gespeichert
                    .attr("cx", function(d) {
                        return d.x;
                    })
                    .attr("cy", function(d) {
                        return d.y;
                    })
            };
        }

        // Cluster bewegen sich miteinander
        function cluster(alpha) {
            return function(d) {
                var cluster = clusters[d.cluster];
                if (cluster === d) return;
                // Anpassung der Knotenposition an die Position des Clusters
                var x = d.x - cluster.x,
                    y = d.y - cluster.y,
                    l = Math.sqrt(x * x + y * y),
                    r = d.radius + scalingOffset + cluster.radius;
                if (l != r) {
                    l = (l - r) / l * alpha;
                    d.x -= x *= l;
                    d.y -= y *= l;
                    cluster.x += x;
                    cluster.y += y;
                }
            };
        }

        // Kollisionen unter den Kreisen werden berechnet
        function collide(alpha) {
            var quadtree = d3.geom.quadtree(nodes);
            return function(d) {
                var r = d.radius + 2 * scalingOffset + maxRadius + Math.max(padding, clusterPadding),
                    nx1 = d.x - r,
                    nx2 = d.x + r,
                    ny1 = d.y - r,
                    ny2 = d.y + r;
                quadtree.visit(function(quad, x1, y1, x2, y2) {
                    if (quad.point && (quad.point !== d)) {
                        var x = d.x - quad.point.x,
                            y = d.y - quad.point.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + 2 * scalingOffset + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
                        if (l < r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            quad.point.x += x;
                            quad.point.y += y;
                        }
                    }
                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                });
            };
        }

        function gravity(alpha) {
            return function(d) {
                var angle = Math.atan2(y - d.y, x - d.x); // angle from center
                var rad = ring(d.radius); // radius of ring of attraction

                // closest point on ring of attraction
                var rx = x - Math.cos(angle) * rad;
                var ry = y - Math.sin(angle) * rad;

                // move towards point
                d.x += (rx - d.x) * alpha;
                d.y += (ry - d.y) * alpha;
            };
        }


    });
    </script>